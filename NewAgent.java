
/**
 * class NewAgent
 *
 * This is a "trial" agent that is being used to test a new algorithm for
 * finding the shortest path to the goal. This algorithm looks at
 * sequences of length 8 in episodic memory and combines the scores from
 * the positional weight matrix, a constituency/substring match algorithm, and the
 * number of steps to the goal to find the best possible
 * next move.
 *
 * @author: Sara Meisburger and Christine Chen
 *
 */
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Random;
 import java.util.Collections;

public class NewAgent extends StateMachineAgent
{
  //episodic memory generated by a "helper" StateMachineAgent
  //for this little NewAgent to use
  protected ArrayList<Episode> generateEpisodicMemory;
  //chance that a duplicate cmd is allowed if a random action is necessary
  double DUPLICATE_FORGIVENESS = .25; //25% chance a duplicate is permitted
  int COMPARE_SIZE = 8;
  public static final String OUTPUT_FILE2 = "sequences.csv";

  /**
  *
  */
  //public static void main(String[] args)
  public NewAgent()
  {
    //create a StateMachineAgent object, have it
    //roam around for a while, and then stash its episodic memory
    //away in genEpisodicMemory
    StateMachineAgent gilligan = new StateMachineAgent();
    gilligan.exploreEnvironment();
    generateEpisodicMemory = gilligan.episodicMemory;
  }

  protected int generateQualityScore(){

    Episode[] originalSequence = new Episode[COMPARE_SIZE];
    Episode[] foundSequence = new Episode[COMPARE_SIZE];
    int lastGoalIndex = findLastGoal(episodicMemory.size());
    int qualityScore = 0;//var to be returned

    if (lastGoalIndex == -1) {
        return qualityScore;//since init to 0's the ending score will be poor
    }

    //If we've just reached the goal in the last 7 steps, then generate random steps until long enough
    if (lastGoalIndex == episodicMemory.size() - 7)
    {
        generateRandomAction();
        generateQualityScore();
    }

    //fill the two arrays we will be comparing
    for (int i=generateEpisodicMemory.size()-1; i<generateEpisodicMemory.size()-(COMPARE_SIZE-1); i--){
      originalSequence[i] = (generateEpisodicMemory.get(generateEpisodicMemory.size()-1-i));
    }
    for (int j=0; j<(COMPARE_SIZE-1); j++){
      foundSequence[j] = (generateEpisodicMemory.get(lastGoalIndex-j));
    }

    try {
        FileWriter csv = new FileWriter(OUTPUT_FILE2);
        for(int i=0; i<8; i++){
          csv.append(originalSequence[i].command);
        }
        for(int i=0; i<8; i++){
          csv.append(foundSequence[i].command);
        }

        csv.close();
      }
      catch (IOException e) {
          System.out.println("tryAllCombos: Could not create file, what a noob...");
          System.exit(-1);
      }
    //test to see if works


    return qualityScore;

  }
  public char generateRandomAction() {
        //decide if a dup command is acceptable
        double chanceForDup = Math.random();
        boolean dupPermitted = false;
        if (chanceForDup < DUPLICATE_FORGIVENESS) {
            dupPermitted = true;
        }

        //keep generating random moves till it is different from last or dups are allowed
        char possibleCmd;
        Episode lastEpisode = generateEpisodicMemory.get(generateEpisodicMemory.size() - 1);
        char lastCommand = lastEpisode.command;

        do {
            possibleCmd = alphabet[random.nextInt(alphabet.length)];
            if (dupPermitted)//if they are allowed we don't care to check for dup
                break;
        } while (possibleCmd == lastCommand); //same cmd, redo loop

		return possibleCmd;
	}


}

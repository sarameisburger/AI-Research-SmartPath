import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import java.util.Collections;
import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.FileOutputStream;

/**
 * class NewAgent
 *
 * This is a "trial" agent that is being used to test a new algorithm for
 * finding the shortest path to the goal. This algorithm looks at
 * sequences of length 8 in episodic memory and combines the scores from
 * the positional weight matrix, a constituency/substring match algorithm, and the
 * number of steps to the goal to find the best possible
 * next move.
 *
 * @author: Sara Meisburger and Christine Chen
 *
 */


public class NewAgent extends StateMachineAgent
{
  //episodic memory generated by a "helper" StateMachineAgent
  //for this little NewAgent to use
  protected ArrayList<Episode> generateEpisodicMemory;
  //chance that a duplicate cmd is allowed if a random action is necessary
  double DUPLICATE_FORGIVENESS = .25; //25% chance a duplicate is permitted
  int COMPARE_SIZE = 8;
  public static final String OUTPUT_FILE2 = "sequences.csv";
  Episode tempEpisode;

  /**
  *
  */
  //public static void main(String[] args)
  public NewAgent()
  {
    //create a StateMachineAgent object, have it
    //roam around for a while, and then stash its episodic memory
    //away in genEpisodicMemory
    //StateMachineAgent gilligan = new StateMachineAgent();
    //gilligan.exploreEnvironment();
    //generateEpisodicMemory = gilligan.episodicMemory;
    generateRandomEpisodes(100);
    System.out.print("score");
  }

  protected int generateQualityScore(){

    Episode[] originalSequence = new Episode[COMPARE_SIZE];
    Episode[] foundSequence = new Episode[COMPARE_SIZE];
    int lastGoalIndex = findLastGoal(episodicMemory.size());
    int qualityScore = 0;//var to be returned

    if (lastGoalIndex == -1) {
        //since qualityScore has been init to 0, the ending score will be poor
        return qualityScore;
    }


    //If we've just reached the goal in the last 8 characters, then generate random steps until long enough
    for(int i=0; i< COMPARE_SIZE; i++){
      if (lastGoalIndex == episodicMemory.size() - i){
        generateRandomAction();
        generateQualityScore();
    }


    //fill the two arrays we will be comparing with 8 episodes
    for (int k=1; k<=COMPARE_SIZE; k++){ //WE CHANGED THIS ON BOTH BRANCHES
      originalSequence[i] = (generateEpisodicMemory.get(generateEpisodicMemory.size()-k));

    for (int j=1; j<=COMPARE_SIZE; j++){
      foundSequence[j] = (generateEpisodicMemory.get(lastGoalIndex-j));
    }

    getCountingScore(originalSequence, foundSequence);


    try {
        FileWriter csv = new FileWriter(OUTPUT_FILE2);
        for(int q=0; q<8; q++){
          csv.append(originalSequence[q].command);
        }
        for(int p=0; p<8; p++){
          csv.append(foundSequence[p].command);
        }

        csv.close();
      }
      catch (IOException e) {
          System.out.println("tryAllCombos: Could not create file, what a noob...");
          System.exit(-1);
      }
    //test to see if works


  }
}
return qualityScore;
}

  protected char generateRandomAction(){
        //decide if a dup command is acceptable
        double chanceForDup = Math.random();
        boolean dupPermitted = false;
        if (chanceForDup < DUPLICATE_FORGIVENESS) {
            dupPermitted = true;
        }

        //keep generating random moves till it is different from last or dups are allowed
        char possibleCmd;
        Episode lastEpisode = generateEpisodicMemory.get(generateEpisodicMemory.size() - 1);
        char lastCommand = lastEpisode.command;

        do {
            possibleCmd = alphabet[random.nextInt(alphabet.length)];
            if (dupPermitted)//if they are allowed we don't care to check for dup
                break;
        } while (possibleCmd == lastCommand); //same cmd, redo loop

		return possibleCmd;
	}

  protected ArrayList<Episode> generateRandomEpisodes(int length){
    //generate random episodes based on chosen length
    for(int i=0; i<length; i++){
      //create a random episode
      Episode tempEpisode = null;
      tempEpisode.command = generateRandomAction();
      tempEpisode.sensorValue = randomAtGoal(50);
      generateEpisodicMemory.add(tempEpisode);
    }
    //PrintWriter writer = new PrintWriter ("outputfile2.txt");
    //PrintWriter out = new PrintWriter(new FileWriter("users\\sarameisburger\\Desktop\\outputfile2.txt"));
    save(generateEpisodicMemory);
    return generateEpisodicMemory;

  }

  public void save(ArrayList<Episode> output) {
  try {
    PrintWriter pw = new PrintWriter(new FileOutputStream(OUTPUT_FILE2));
  for (Episode episode : output)
      pw.println(episode.command);
  pw.close();
}
  catch (IOException e) {
    System.out.println("tryAllCombos: Could not create file, what a noob...");
    System.exit(-1);
}
}

  //randomly gives an "at goal?" value of 0 or 1
  public int randomAtGoal(int probability){
    int atGoal = (int)(Math.random()*probability);
    if(atGoal == 0){
      return 1; //say it reeached the goal
    }
    else {
      return 0; //otherwise it did not reach the goal
    }
  }

  public char getChar(Episode epi){
    return epi.command;
  }

  protected int generateQualityScore(){

    Episode[] originalSequence = new Episode[COMPARE_SIZE];
    Episode[] foundSequence = new Episode[COMPARE_SIZE];
    int lastGoalIndex = findLastGoal(episodicMemory.size());
    int qualityScore = 0;//var to be returned

    if (lastGoalIndex == -1) {
        //since qualityScore has been init to 0, the ending score will be poor
        return qualityScore;
    }


    //If we've just reached the goal in the last 8 characters, then generate random steps
    //until we have a long enough original sequence
    for(int i=0; i< COMPARE_SIZE; i++){
      if (lastGoalIndex == episodicMemory.size() - i){
        generateRandomAction();
        generateQualityScore();
    }


    //fill the two arrays we will be comparing with 8 episodes
    //GENERATEEPISODICMEMORY.SIZE()-i-1
    for (int i=0; i<COMPARE_SIZE; i++){
      originalSequence[i] = (generateEpisodicMemory.get(generateEpisodicMemory.size()-i));

    for (int j=0; j<(COMPARE_SIZE); j++){
      foundSequence[j] = (generateEpisodicMemory.get(lastGoalIndex-j));
    }


    try {
        FileWriter csv = new FileWriter(OUTPUT_FILE2);
        for(int i=0; i<8; i++){
          csv.append(originalSequence[i].command);
        }
        for(int i=0; i<8; i++){
          csv.append(foundSequence[i].command);
        }

        csv.close();
      }
      catch (IOException e) {
          System.out.println("tryAllCombos: Could not create file, what a noob...");
          System.exit(-1);
      }
    //test to see if works


    return qualityScore;

  }
}
}
/**
*Step by step what this method does
* 1. turns the array of characters found and original, into one long string each
* 2. iterates through each the found string and original string and finds all subsequences
* 3. compares each subsequence to the other, if it finds one it moves on to avoid overcounting

*/

  public int getCountingScore(Episode[] original, Episode[] found){
    ArrayList<String> originalSubsequences = null;
    ArrayList<String> foundSubsequences = null;
    int count = 0; //counter for how many subsequences match
    int score = 0; //score for matching subsequences, longer sub = higher score

    String originalString = original.toString(); //make arrays into string to get subsequences
    String foundString = found.toString();

    //get arraylist of subsequences for original
    for(int i=0; i<originalString.length(); i++){ // i determines length of string
      for(int j=0; j<originalString.length()-i; j++){ // j determines where we start (indice) in string
        originalSubsequences.add(originalString.substring(j,j+i));
      }
    }
    //get arraylist of subsequences for found
    for(int g=0; g<foundString.length(); g++){
      for(int f=0; f<foundString.length()-g; f++){
        foundSubsequences.add(foundString.substring(f,f+g));
      }
    }
    //for each subsequence in original, compare to see if it is in found list of subsequences
    for(int p=0; p<originalSubsequences.size(); p++){
      for(int q=0; q<foundSubsequences.size(); q++){
        if(originalSubsequences.get(p).equals(foundSubsequences.get(q))){
          count++;
          score = originalSubsequences.get(p).length() + score;
          foundSubsequences.remove(q); //avoid overcounting, once counted, remove
          //p++;
          break;
           //if found matching sequence, move on to next i so we don't repeat counting
          //use break instead of p++ to get out of inner for loop
          //generate number between 0 and 1 for score...divide by max score 1=best
          //fairly evenly
        }
      }
    }
    System.out.print("score");
    return score;
  }

}

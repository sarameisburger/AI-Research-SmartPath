
/**
 * class NewAgent
 *
 * This is a "trial" agent that is being used to test a new algorithm for
 * finding the shortest path to the goal. This algorithm looks at
 * sequences of length 8 in episodic memory and combines the scores from
 * the positional weight matrix, a constituency/substring match algorithm, and the
 * number of steps to the goal to find the best possible
 * next move.
 *
 * @author: Sara Meisburger and Christine Chen
 *
 */
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Random;
 import java.util.Collections;

public class NewAgent extends StateMachineAgent
{
  //episodic memory generated by a "helper" StateMachineAgent
  //for this little NewAgent to use
  protected ArrayList<Episode> generateEpisodicMemory;
  //chance that a duplicate cmd is allowed if a random action is necessary
  double DUPLICATE_FORGIVENESS = .25; //25% chance a duplicate is permitted
  int COMPARE_SIZE = 8;

  /**
  *
  */
  //public static void main(String[] args)
  public NewAgent()
  {
    //create a StateMachineAgent object, have it
    //roam around for a while, and then stash its episodic memory
    //away in genEpisodicMemory
    StateMachineAgent gilligan = new StateMachineAgent();
    gilligan.exploreEnvironment();
    generateEpisodicMemory = gilligan.episodicMemory;
  }

  protected int generateQualityScore(){

    char[] originalSequence = new char[COMPARE_SIZE];
    char[] foundSequence = new char[COMPARE_SIZE];
    int lastGoalIndex = findLastGoal(episodicMemory.size());
    int qualityScore = 0//var to be returned

    if (lastGoalIndex == -1) {
        return scoreInfo;//since init to 0's the ending score will be poor
    }

    //If we've just reached the goal in the last 7 steps, then generate random steps until long enough
    if (lastGoalIndex == episodicMemory.size() - 7)
    {
        generateRandomAction();
        generateQualityScore();
    }

    //fill the two arrays we will be comparing
    for (i=generateEpisodicMemory.size()-1; i<generateEpisodicMemory.size()-(COMPARE_SIZE-1); i--){
      originalSequence[i] = generateEpisodicMemory[generateEpisodicMemory.size()-1-i];
    }
    for (j=0; j<(COMPARE_SIZE-1); j++){
      foundSequence[j] = generateEpisodicMemory[lastGoalIndex-j];
    }

    //test to see if works
    for(i=0; i<8; i++){
      System.out.print(originalSequence[i]);
    }
    for(i=0; i<8; i++){
      System.out.print(foundSequence[i]);
    }

  }
  public char generateRandomAction() {
        //decide if a dup command is acceptable
        double chanceForDup = Math.random();
        boolean dupPermitted = false;
        if (chanceForDup < DUPLICATE_FORGIVENESS) {
            dupPermitted = true;
        }

        //keep generating random moves till it is different from last or dups are allowed
        char possibleCmd;
        Episode lastEpisode = generateEpisodicMemory.get(generateEpisodicMemory.size() - 1);
        char lastCommand = lastEpisode.command;

        do {
            possibleCmd = alphabet[random.nextInt(alphabet.length)];
            if (dupPermitted)//if they are allowed we don't care to check for dup
                break;
        } while (possibleCmd == lastCommand); //same cmd, redo loop

		return possibleCmd;
	}
}
